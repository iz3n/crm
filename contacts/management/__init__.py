"""
Management command to generate ~3 million test records for the CRM system.
Usage: python manage.py generate_data [--count COUNT]
"""
from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone as django_timezone
from contacts.models import Address, AppUser, CustomerRelationship
from faker import Faker
import random
import uuid
from datetime import timedelta, timezone as dt_timezone

fake = Faker()


class Command(BaseCommand):
    help = 'Generate test data for the CRM system (default: 3,000,000 records)'

    def add_arguments(self, parser):
        parser.add_argument(
            '--count',
            type=int,
            default=3000000,
            help='Number of AppUser records to generate (default: 3000000)',
        )
        parser.add_argument(
            '--batch-size',
            type=int,
            default=10000,
            help='Batch size for bulk operations (default: 10000)',
        )

    def handle(self, *args, **options):
        count = options['count']
        batch_size = options['batch_size']
        
        self.stdout.write(self.style.SUCCESS(f'Starting data generation for {count:,} records...'))
        
        # Disable signals for better performance
        from django.db.models.signals import pre_save, post_save
        pre_save.receivers = []
        post_save.receivers = []
        
        # Generate addresses first (fewer addresses, reused by users)
        address_count = count // 10  # 10 users per address on average
        self.stdout.write(f'Generating {address_count:,} addresses...')
        addresses = self.generate_addresses(address_count, batch_size)
        
        # Generate AppUsers
        self.stdout.write(f'Generating {count:,} AppUsers...')
        self.generate_appusers(count, addresses, batch_size)
        
        self.stdout.write(self.style.SUCCESS(f'Successfully generated {count:,} records!'))

    def generate_addresses(self, count, batch_size):
        """Generate Address records in batches and return list of address IDs"""
        created_count = 0
        
        for i in range(0, count, batch_size):
            batch = []
            current_batch_size = min(batch_size, count - i)
            
            for _ in range(current_batch_size):
                address = Address(
                    street=fake.street_name(),
                    street_number=str(random.randint(1, 9999)),
                    city_code=fake.postcode(),
                    city=fake.city(),
                    country=fake.country()
                )
                batch.append(address)
            
            Address.objects.bulk_create(batch, ignore_conflicts=True)
            created_count += len(batch)
            
            if created_count % (batch_size * 10) == 0:
                self.stdout.write(f'  Created {created_count:,} addresses...')
        
        self.stdout.write(self.style.SUCCESS(f'  Created {created_count:,} addresses'))
        
        # Fetch all address IDs from database
        # Using only() to reduce memory usage - we only need IDs
        address_ids = list(Address.objects.values_list('id', flat=True))
        return address_ids

    def generate_appusers(self, count, address_ids, batch_size):
        """Generate AppUser and CustomerRelationship records in batches"""
        genders = ['M', 'F', 'O']
        created_count = 0
        address_index = 0
        address_count = len(address_ids)
        
        # Get the starting ID to track newly created users
        try:
            last_id = AppUser.objects.latest('id').id
        except AppUser.DoesNotExist:
            last_id = 0
        
        for i in range(0, count, batch_size):
            current_batch_size = min(batch_size, count - i)
            
            # Prepare batches
            appuser_batch = []
            relationship_batch = []
            
            for j in range(current_batch_size):
                # Create AppUser - customer_id will be auto-generated by the model
                appuser = AppUser(
                    first_name=fake.first_name(),
                    last_name=fake.last_name(),
                    gender=random.choice(genders) if random.random() > 0.1 else None,
                    # customer_id is auto-generated by the model's default function
                    phone_number=fake.phone_number() if random.random() > 0.1 else None,
                    created=fake.date_time_between(start_date='-5y', end_date='now', tzinfo=dt_timezone.utc),
                    birthday=fake.date_of_birth(minimum_age=18, maximum_age=80) if random.random() > 0.2 else None,
                )
                appuser_batch.append(appuser)
            
            # Bulk create AppUsers
            # Use ignore_conflicts to handle any duplicate customer_ids gracefully
            AppUser.objects.bulk_create(appuser_batch, ignore_conflicts=True)
            
            # Fetch the created users to get their IDs for relationships
            # Since customer_id is auto-generated, we fetch users with ID greater than last_id
            # This ensures we get the users we just created
            created_users = list(
                AppUser.objects.filter(id__gt=last_id)
                .order_by('id')[:current_batch_size]
                .select_related('address', 'relationship')
            )
            
            # Update last_id for next iteration
            if created_users:
                last_id = created_users[-1].id
            
            # Assign address to each user (single address per user)
            for idx, appuser in enumerate(created_users):
                if address_count > 0:
                    # Get address ID (cycle through addresses)
                    address_id = address_ids[address_index % address_count]
                    appuser.address_id = address_id
                    appuser.save(update_fields=['address_id'])
                    address_index += 1
            
            # Create relationships for users that don't already have one
            for appuser in created_users:
                # Check if relationship already exists
                if not hasattr(appuser, 'relationship'):
                    relationship = CustomerRelationship(
                        appuser=appuser,
                        points=random.randint(0, 100000),
                        created=appuser.created,
                        last_activity=fake.date_time_between(
                            start_date=appuser.created,
                            end_date='now',
                            tzinfo=dt_timezone.utc
                        )
                    )
                    relationship_batch.append(relationship)
            
            if relationship_batch:
                CustomerRelationship.objects.bulk_create(relationship_batch, ignore_conflicts=True)
            
            created_count += len(appuser_batch)
            
            if created_count % (batch_size * 10) == 0:
                self.stdout.write(f'  Created {created_count:,} AppUsers...')
        
        self.stdout.write(self.style.SUCCESS(f'  Created {created_count:,} AppUsers with relationships'))

